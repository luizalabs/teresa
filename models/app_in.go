package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

/*AppIn Application data

swagger:model AppIn
*/
type AppIn struct {

	/* auto scale
	 */
	AutoScale *AutoScale `json:"autoScale,omitempty"`

	/* health check
	 */
	HealthCheck *AppInHealthCheck `json:"healthCheck,omitempty"`

	/* limits
	 */
	Limits *AppInLimits `json:"limits,omitempty"`

	/* the name of the app

	Required: true
	Pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	*/
	Name *string `json:"name"`

	/* app process type

	Pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	*/
	ProcessType *string `json:"processType,omitempty"`

	/* rolling update
	 */
	RollingUpdate *AppInRollingUpdate `json:"rollingUpdate,omitempty"`

	/* number of PODs running the app

	Minimum: 1
	*/
	Scale int64 `json:"scale,omitempty"`

	/* the name of the team that this app belongs.
	if the user is in only one team, this is parameter is not required


	Required: true
	Pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	*/
	Team *string `json:"team"`
}

// Validate validates this app in
func (m *AppIn) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAutoScale(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateHealthCheck(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLimits(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProcessType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRollingUpdate(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateScale(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTeam(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AppIn) validateAutoScale(formats strfmt.Registry) error {

	if swag.IsZero(m.AutoScale) { // not required
		return nil
	}

	if m.AutoScale != nil {

		if err := m.AutoScale.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *AppIn) validateHealthCheck(formats strfmt.Registry) error {

	if swag.IsZero(m.HealthCheck) { // not required
		return nil
	}

	if m.HealthCheck != nil {

		if err := m.HealthCheck.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *AppIn) validateLimits(formats strfmt.Registry) error {

	if swag.IsZero(m.Limits) { // not required
		return nil
	}

	if m.Limits != nil {

		if err := m.Limits.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *AppIn) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.Pattern("name", "body", string(*m.Name), `^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`); err != nil {
		return err
	}

	return nil
}

func (m *AppIn) validateProcessType(formats strfmt.Registry) error {

	if swag.IsZero(m.ProcessType) { // not required
		return nil
	}

	if err := validate.Pattern("processType", "body", string(*m.ProcessType), `^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`); err != nil {
		return err
	}

	return nil
}

func (m *AppIn) validateRollingUpdate(formats strfmt.Registry) error {

	if swag.IsZero(m.RollingUpdate) { // not required
		return nil
	}

	if m.RollingUpdate != nil {

		if err := m.RollingUpdate.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *AppIn) validateScale(formats strfmt.Registry) error {

	if swag.IsZero(m.Scale) { // not required
		return nil
	}

	if err := validate.MinimumInt("scale", "body", int64(m.Scale), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *AppIn) validateTeam(formats strfmt.Registry) error {

	if err := validate.Required("team", "body", m.Team); err != nil {
		return err
	}

	if err := validate.Pattern("team", "body", string(*m.Team), `^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`); err != nil {
		return err
	}

	return nil
}

/*AppInHealthCheck app health check

swagger:model AppInHealthCheck
*/
type AppInHealthCheck struct {

	/* check if the app is responding.
	containers of the app will be restarted if this check fails

	*/
	Liveness *HealthCheckProbe `json:"liveness,omitempty"`

	/* check if the app is fully working.
	containers of the app will be removed from service endpoints if the check fails

	*/
	Readiness *HealthCheckProbe `json:"readiness,omitempty"`
}

// Validate validates this app in health check
func (m *AppInHealthCheck) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLiveness(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateReadiness(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AppInHealthCheck) validateLiveness(formats strfmt.Registry) error {

	if swag.IsZero(m.Liveness) { // not required
		return nil
	}

	if m.Liveness != nil {

		if err := m.Liveness.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *AppInHealthCheck) validateReadiness(formats strfmt.Registry) error {

	if swag.IsZero(m.Readiness) { // not required
		return nil
	}

	if m.Readiness != nil {

		if err := m.Readiness.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

/*AppInLimits specifies the limit ranges of the APP

swagger:model AppInLimits
*/
type AppInLimits struct {

	/* default

	Required: true
	*/
	Default []*LimitRangeQuantity `json:"default"`

	/* default request

	Required: true
	*/
	DefaultRequest []*LimitRangeQuantity `json:"defaultRequest"`

	/* limit request ratio
	 */
	LimitRequestRatio []*LimitRangeQuantity `json:"limitRequestRatio,omitempty"`

	/* max
	 */
	Max []*LimitRangeQuantity `json:"max,omitempty"`

	/* min
	 */
	Min []*LimitRangeQuantity `json:"min,omitempty"`
}

// Validate validates this app in limits
func (m *AppInLimits) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefault(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDefaultRequest(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLimitRequestRatio(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMax(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMin(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AppInLimits) validateDefault(formats strfmt.Registry) error {

	if err := validate.Required("limits"+"."+"default", "body", m.Default); err != nil {
		return err
	}

	for i := 0; i < len(m.Default); i++ {

		if swag.IsZero(m.Default[i]) { // not required
			continue
		}

		if m.Default[i] != nil {

			if err := m.Default[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *AppInLimits) validateDefaultRequest(formats strfmt.Registry) error {

	if err := validate.Required("limits"+"."+"defaultRequest", "body", m.DefaultRequest); err != nil {
		return err
	}

	for i := 0; i < len(m.DefaultRequest); i++ {

		if swag.IsZero(m.DefaultRequest[i]) { // not required
			continue
		}

		if m.DefaultRequest[i] != nil {

			if err := m.DefaultRequest[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *AppInLimits) validateLimitRequestRatio(formats strfmt.Registry) error {

	if swag.IsZero(m.LimitRequestRatio) { // not required
		return nil
	}

	for i := 0; i < len(m.LimitRequestRatio); i++ {

		if swag.IsZero(m.LimitRequestRatio[i]) { // not required
			continue
		}

		if m.LimitRequestRatio[i] != nil {

			if err := m.LimitRequestRatio[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *AppInLimits) validateMax(formats strfmt.Registry) error {

	if swag.IsZero(m.Max) { // not required
		return nil
	}

	for i := 0; i < len(m.Max); i++ {

		if swag.IsZero(m.Max[i]) { // not required
			continue
		}

		if m.Max[i] != nil {

			if err := m.Max[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *AppInLimits) validateMin(formats strfmt.Registry) error {

	if swag.IsZero(m.Min) { // not required
		return nil
	}

	for i := 0; i < len(m.Min); i++ {

		if swag.IsZero(m.Min[i]) { // not required
			continue
		}

		if m.Min[i] != nil {

			if err := m.Min[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

/*AppInRollingUpdate params to use when starting a new deployment

swagger:model AppInRollingUpdate
*/
type AppInRollingUpdate struct {

	/* specifies the maximum number of PODs that can be created above the desired number of PODs during deployment.
	this can be percentage (of the scale) or a specific number os PODs


	Required: true
	Min Length: 1
	Pattern: ^\d+%?$
	*/
	MaxSurge *string `json:"maxSurge"`

	/* specifies the maximun number of unavailable PODs during deployment percentage (of the desired scale).
	this can be percentage (of the scale) or a specific number os PODs


	Required: true
	Min Length: 1
	Pattern: ^\d+%?$
	*/
	MaxUnavailable *string `json:"maxUnavailable"`
}

// Validate validates this app in rolling update
func (m *AppInRollingUpdate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMaxSurge(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMaxUnavailable(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AppInRollingUpdate) validateMaxSurge(formats strfmt.Registry) error {

	if err := validate.Required("rollingUpdate"+"."+"maxSurge", "body", m.MaxSurge); err != nil {
		return err
	}

	if err := validate.MinLength("rollingUpdate"+"."+"maxSurge", "body", string(*m.MaxSurge), 1); err != nil {
		return err
	}

	if err := validate.Pattern("rollingUpdate"+"."+"maxSurge", "body", string(*m.MaxSurge), `^\d+%?$`); err != nil {
		return err
	}

	return nil
}

func (m *AppInRollingUpdate) validateMaxUnavailable(formats strfmt.Registry) error {

	if err := validate.Required("rollingUpdate"+"."+"maxUnavailable", "body", m.MaxUnavailable); err != nil {
		return err
	}

	if err := validate.MinLength("rollingUpdate"+"."+"maxUnavailable", "body", string(*m.MaxUnavailable), 1); err != nil {
		return err
	}

	if err := validate.Pattern("rollingUpdate"+"."+"maxUnavailable", "body", string(*m.MaxUnavailable), `^\d+%?$`); err != nil {
		return err
	}

	return nil
}
